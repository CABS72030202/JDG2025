/*
 * pwm_test.c
 * Created on: 2024-12-22
 * Author: Sebastien Cabana
 *
 * Description:
 * This program is designed to test and control a brushless motor for the BOAT robot 
 * using precise PWM signals generated by the Raspberry Pi. The motor follows a specific 
 * startup routine: providing power (5V), sending a 50 Hz PWM signal with a 5% duty cycle 
 * to initialize, and then controlling the speed by varying the duty cycle between 5% 
 * (stopped) and 10% (maximum speed).
 *
 * The program uses the WiringPi library to configure and control the PWM pins, leveraging 
 * its functions for clock settings, range adjustments, and PWM signal generation.
 * 
 * Usage:
 * 1. Compile the program using the following command:
 *    gcc -o pwm_test pwm_test.c -lwiringPi
 *
 * 2. Run the compiled program to begin listening for gamepad inputs:
 *    ./pwm_test
 *
 * Reference:
 * https://www.electronicwings.com/raspberry-pi/raspberry-pi-pwm-generation-using-python-and-c
 */

// Includes
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <wiringPi.h>

// Enums and Structs
typedef struct {
    char side;              // 'R' or 'L'
    float speed;            // Current speed as percentage (0.0 to 1.0)
    int multiplier;         // Current speed as multiplier
    int motor_pin;    // GPIO Pin for the motor pwm
    int power_pin;    // GPIO Pin to provide 5V power to the motor
} Brushless;

// Pin Definitions
#define LEFT_MOTOR_PWM_PIN    26      // GPIO Pin for the left motor PWM
#define LEFT_POWER_GPIO_PIN   22      // GPIO Pin to provide 5V power to the left motor

// Global Constants
#define ROBOT_ID        6       // Unique ID to each Arduino : RED is 0, GREEN is 1, BLUE is 2, YELLOW is 3, PURPLE is 4, CONE is 5, BOAT is 6
#define MAX_SPEED       3       // Maximum speed multiplier for the robot

// PWM Constants
#define PWM_RANGE       1024    // Range for PWM (0-1023)
#define PWM_CLOCK_DIV   384     // Clock divisor for 50 Hz frequency (19.2 MHz / (384 * 1024) = 50 Hz)
#define DUTY_CYCLE_STOP 51      // 5% duty cycle (5% of 1024)
#define DUTY_CYCLE_MAX  102     // 10% duty cycle (10% of 1024)
#define INIT_DELAY      1000    // Time delay for brushless motor initialization
#define INCREASE_DELAY  30      // Time delay when increasing speed (in ms)

// Global Variables
Brushless left_motor;
char message[] = "0:00:00:0\r\n";


// Function Prototypes
int PWM_Init();
void Motor_Startup(Brushless*);
void Set_Motor_Speed(Brushless*);
void Reset_Motor(Brushless*);
int Get_Motor_Multiplier(Brushless*);

int main() {
    // Initialize PWM
    if(PWM_Init())
        return 1;

    // Run example 5 times 
    for(int i = 0; i < 5; i++) {
        // Example: Test motor speed from 0% to 100%
        for (int i = 0; i < MAX_SPEED; i++) {
            message[3] = i + '0';
            Set_Motor_Speed(&left_motor);
            printf("Motor running at %.0f%% speed.\n", left_motor.speed * 100);
            delay(1000); 
        }
    }

    // Stop the motor
    message[3] = '0';
    Set_Motor_Speed(&left_motor);
    printf("Motor stopped.\n");
    delay(2000);
    return 0;
}

int PWM_Init() {
    // Initialize wiringPi
    if (wiringPiSetup() == -1) {
        fprintf(stderr, "Unable to start wiringPi: %s\n", strerror(errno));
        return 1;
    }

    // Set PWM pin mode
    pinMode(LEFT_MOTOR_PWM_PIN, PWM_OUTPUT);

    // Set GPIO pin for motor power
    pinMode(LEFT_POWER_GPIO_PIN, OUTPUT);

    // Configure PWM clock and range for 50 Hz frequency
    pwmSetMode(PWM_MODE_MS);     // Use Mark:Space mode for stable frequency
    pwmSetClock(PWM_CLOCK_DIV); // Set clock divisor
    pwmSetRange(PWM_RANGE);     // Set range

    printf("PWM initialized for 50 Hz operation.\n");

    // Initialize motor structs
    left_motor.side = 'L';
    left_motor.speed = 0.0;
    left_motor.multiplier = 0;
    left_motor.motor_pin = LEFT_MOTOR_PWM_PIN;
    left_motor.power_pin = LEFT_POWER_GPIO_PIN;

    return 0;
}

void Motor_Startup(Brushless* motor) {
    // Provide power to the motor
    digitalWrite(motor->power_pin, HIGH);

    // Send a 5% duty cycle signal to initialize the motor
    pwmWrite(motor->motor_pin, DUTY_CYCLE_STOP);

    // Wait for motor initialization
    delay(INIT_DELAY);
}

void Set_Motor_Speed(Brushless* motor) {
    // Save previous speed
    float prev_speed = motor->speed;

    // Convert multiplier to percentage
    motor->speed = Get_Motor_Multiplier(motor) / (float)MAX_SPEED;
    
    // Calculate the previous and new PWM value based on the speed percentage
    int prev_pwmValue = DUTY_CYCLE_STOP + (int)((DUTY_CYCLE_MAX - DUTY_CYCLE_STOP) * prev_speed);
    int pwmValue = DUTY_CYCLE_STOP + (int)((DUTY_CYCLE_MAX - DUTY_CYCLE_STOP) * motor->speed);

    // Reset motor if null speed to prevent motor getting stuck
    if(motor->speed == 0.0)
        Reset_Motor(motor);

    // Slowly increase the PWM value to the motor pin
    else
        for(int i = prev_pwmValue; i < pwmValue; i++) {
            pwmWrite(motor->motor_pin, i);
            delay(INCREASE_DELAY);
        }

    printf("Motor speed set to %.0f%% (PWM value: %d | Multiplier value : %i).\n", motor->speed * 100, pwmValue, Get_Motor_Multiplier(motor));
}

void Reset_Motor(Brushless* motor) {
    digitalWrite(motor->power_pin, LOW);
    delay(0.5 * INIT_DELAY);
    Motor_Startup(motor);
}

int Get_Motor_Multiplier(Brushless* motor) {
    switch(motor->side) {
        case 'R':   motor->multiplier = message[6] - '0'; break;
        case 'L':   motor->multiplier = message[3] - '0'; break;
        default:    printf("Error. Wrong side in Get_Motor_Multiplier.\n"); return -1;
    }
    return motor->multiplier;
}